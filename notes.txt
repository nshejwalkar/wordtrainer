need cors in order for same host/origin frontend to communicate with backend.
automatic realoading is usually due to default form behavior, but for me it was live reload

image processing
pytesseract is a library on top of the tesseract engine
iphones do not ss and sr at the same res. as native resolution

problem (star):
Im working on this app to analyze word hunt video gameplay, and send back stats based on how the user played. 
I set up a basic html js frontend, flask backend. I was sending a post reuest with the video data to my flask app and expecting it to send me back some data after processing. i took a couple days off of working on the routing part of the app to work on like the image processing stuff, and after I was satisfied with that, I wanted to make sure it could feed data to the frontend correctly. So I started up my flask app, but I kept on receiving a response that was different than the one I was trying to send back. After some thinking, I realized it was sending me back a string from an older version of my flask app. 
- My first thought was that something was getting wrongly cached. So I turned off the caching in chrome and deleted my __pycache__ folder.
- I then realized that my flask app wasnt in debug mode, and that it probably wasnt reloading to the changes in my app. So I set it to debug mode and tried changing some flask env variables, but after I confirmed that it was updating, and the problem was still there, I ruled that out.
- next thing I did was look at the network traffic using chrome devtools. Looking at the network tab, I could see that my frontend was still sending the reuest to the address and port that my flask app was running on. So I decided to take down the backend completely, and after rerunning that same process, it was still sending it to the same address and port.
- i was confused at that point, but I decided to use netstat | findstr 5000 to check what was running there if anything, and it turns out there was an instance of my backend still running somehow. i used powershell and realized it had been running for over 3 days in the background.
I just killed the process and the app worked fine now.


to start:
flask run from cmd (be in backend folder)
click on frontend/index.html then start live server

scraping words:
- figure out why even at 120 fps, the frame counts are off
- either have smarter preprocessing for the words or have variable cropping based on the number (number not guaranteed either though)

future:
- standardize video for all iphone sr resolutions 


Troubles with ocr:
reading the board is tough. i tried tesseract and it was unpredictably messing up on inputs that should have been obvious. fine, but this task is critical for everything else to work, it needs to be 100% accurate.
I tried template matching, but realized that was very very sensitive to different scaling, noise, etc.
decided to train my own cnn. used a small 3 layer, 26k param architecture that gpt gave me, and set up a training folder with 26 folders, one for each letter.
to create the data set, use create_augments:
- took a lot of pictures of boards, around 20 or so
- ran the same cropping, image filtering pipeline as I did for actual inference (grayscale, binary filtering, dilating, etc.) 
   - ended up changing some things: i didnt realize that videos and images have different lighting conditions - quick and dirty fix, just a different threshold for each
   - for different resolutions (but same aspect ratio), you need to resize down/up to 90x90
- autosorted the cropped tiles into the 26 folders based on tesseract. if lower than a certain confidence level, i manually sorted those tile myself.
- augmented first just based on random dilation, erosion, blur and brightness+contrast.
- i realized its much much better to lock down the process by controlling the seed and tracking checkpoint pts.
- resulted in much faster than tesseract, but probably worse on outputs. tuned augmentation to 750 tiles per letter and added slight zooms
- trying different seeds is actually a strat. should jump to 97% ish for this easy of a task after an epoch.
- was great but still messing up W and H for some odd reason. i didnt want to change the data augmentation any more, so finetuning seemed like a stretch.
- simply added a layer (26k -> 100k) and it works fine as of now.